/**
 * Swagger Maven Plugin Sample
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class TransportModuleServiceApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Permette di attivare/riattivare un mezzo su un servizio
     * @summary activationVehicle
     * @param body 
     */
    public activationVehicleService(body?: models.ActivationVehicleInputDTO, extraHttpRequestParams?: any): Observable<models.ActivationVehicleDTO> {
        return this.activationVehicleServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di aggiungere una prenotazione ad un servizio pre-esistente
     * @summary addBookingToService
     * @param body 
     */
    public addBookingToService(body?: models.BookingToServiceInputDTO, extraHttpRequestParams?: any): Observable<models.ServiceDTO> {
        return this.addBookingToServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiunge i membri di un equipaggio a un servuzui
     * @summary addCrewMembersToService
     * @param body 
     */
    public addCrewMembersToService(body?: models.RequestAddCrewMembersToService, extraHttpRequestParams?: any): Observable<models.ServiceCrewDTO> {
        return this.addCrewMembersToServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di aggiungere un veicolo ad un servizio
     * @summary addVehicleToService
     * @param body 
     */
    public addVehicleToService(body?: models.AddVehicleToServiceDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.addVehicleToServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di archiviare la prenotazione creando un servizio chiuso connesso.
     * @summary archiveBooking
     * @param body 
     */
    public archiveBooking(body?: models.ArchiveBookingDTO, extraHttpRequestParams?: any): Observable<models.ArchiveBookingResultDTO> {
        return this.archiveBookingWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di archiviare il servizio in input
     * @summary archiveService
     * @param body 
     */
    public archiveService(body?: models.ArchiveServiceDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.archiveServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di verificare e segnalare la differenza di date tra la prenotazione e il servizio a cui aggiungerlo
     * @summary checkDifferentDateAddBookingToService
     * @param body 
     */
    public checkDifferentDateAddBookingToService(body?: models.BookingToServiceInputDTO, extraHttpRequestParams?: any): Observable<models.CheckResultDTO> {
        return this.checkDifferentDateAddBookingToServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di verificare se un servizio � stato gestito
     * @summary checkIsManaged
     * @param idService 
     */
    public checkIsManaged(idService: string, extraHttpRequestParams?: any): Observable<models.CheckResultDTO> {
        return this.checkIsManagedWithHttpInfo(idService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di rilevare se di un servizio sono stati pagati quelli non in regime SSN
     * @summary checkNonSSNBookingPaid
     * @param idService 
     */
    public checkNonSSNBookingPaid(idService: string, extraHttpRequestParams?: any): Observable<models.CheckResultDTO> {
        return this.checkNonSSNBookingPaidWithHttpInfo(idService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di verificare se un servizio � stato servito
     * @summary checkUndispatchedService
     * @param idService 
     */
    public checkUndispatchedService(idService: string, extraHttpRequestParams?: any): Observable<models.CheckResultDTO> {
        return this.checkUndispatchedServiceWithHttpInfo(idService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di creare il servizio per la lista dei trasporti in input
     * @summary createService
     * @param body 
     */
    public createService(body?: models.CreateServiceDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.createServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary filterAdvancedTransports
     * @param body 
     */
    public filterAdvancedTransports(body?: models.FiltroSinotticoAvanzato, extraHttpRequestParams?: any): Observable<models.SearchTransportResultDTO> {
        return this.filterAdvancedTransportsWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary filterTransports
     * @param body 
     */
    public filterTransports(body?: models.FiltroSinottico, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.filterTransportsWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * recupera la lista dei booking ciclici collegati per la gestione dei virtual service
     * @summary getCiclicalBookingForVirtualService
     * @param body 
     */
    public getCiclicalBookingForVirtualService(body?: models.CreateVirtualServiceDTO, extraHttpRequestParams?: any): Observable<Array<models.CiclicalBookingForVirtualServiceDTO>> {
        return this.getCiclicalBookingForVirtualServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Servizio individuato attraverso il suo Id
     * @summary getServiceById
     * @param idService 
     */
    public getServiceById(idService: string, extraHttpRequestParams?: any): Observable<models.ServiceDTO> {
        return this.getServiceByIdWithHttpInfo(idService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * REstituisce i membri di equipaggio asseganti ad un servizio
     * @summary getServiceCrewMembers
     * @param idService 
     */
    public getServiceCrewMembers(idService: string, extraHttpRequestParams?: any): Observable<Array<models.CrewMemberDTO>> {
        return this.getServiceCrewMembersWithHttpInfo(idService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * La lista dei veicoli attivi, esclusi quelli associati al servizio in input se presente
     * @summary getWorkingResources
     * @param body 
     */
    public getWorkingResourceList(body?: models.WorkingResourceInputDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.getWorkingResourceListWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Verifica se la prenotazione ha rilevamento orario
     * @summary hasTimestampBookingService
     * @param body 
     */
    public hasTimestampBookingService(body?: models.RequestRemoveBookingFromService, extraHttpRequestParams?: any): Observable<models.CheckResultDTO> {
        return this.hasTimestampBookingServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Recupera i nominativi dell'equipaggio disponibili rimuovendo quelli con id presenti in input
     * @summary crewMembers
     */
    public loadCrewMembers(extraHttpRequestParams?: any): Observable<Array<models.CrewMemberDTO>> {
        return this.loadCrewMembersWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Recupera i motivi di rilascio del mezzo
     * @summary loadDeallocateReasons
     * @param travelCompleted 
     */
    public loadDeallocateReasons(travelCompleted?: boolean, extraHttpRequestParams?: any): Observable<models.GenericResultDTODeallocateReasonDTO> {
        return this.loadDeallocateReasonsWithHttpInfo(travelCompleted, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Recupera i tipi di pause
     * @summary loadPauseType
     */
    public loadPauseType(extraHttpRequestParams?: any): Observable<models.GenericResultDTOPauseTypeDTO> {
        return this.loadPauseTypeWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Modifica il nome della postazione
     * @summary modifyInterventionPosition
     * @param body 
     */
    public modifyInterventionPosition(body?: models.VehiclePositionToChangeRequest, extraHttpRequestParams?: any): Observable<models.VehiclePositionToChangeRequest> {
        return this.modifyInterventionPositionWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Sposta un mezzo nella postazione selezionata
     * @summary moveInterventionOnArrival
     * @param body 
     */
    public moveInterventionOnArrival(body?: models.MoveInterventionPositionRequestDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.moveInterventionOnArrivalWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Avvia un mezzo alla destinazione selezionata
     * @summary moveInterventionOnDestination
     * @param body 
     */
    public moveInterventionOnDestination(body?: models.MoveInterventionPositionRequestDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.moveInterventionOnDestinationWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Sposta la tappa di prenotazioni accorpate
     * @summary moveInterventionPosition
     * @param body 
     */
    public moveInterventionPosition(body?: models.MoveInterventionRequestDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTOServiceDTO> {
        return this.moveInterventionPositionWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di spostare un veicolo da un ad un altro
     * @summary moveVehicleToOtherService
     * @param body 
     */
    public moveVehicleToOtherService(body?: models.MoveVehicleToOtherServiceDTO, extraHttpRequestParams?: any): Observable<models.MoveVehicleToOtherServiceResultDTO> {
        return this.moveVehicleToOtherServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Rimuove un veicolo da un servizio
     * @summary releaseVehicleFromService
     * @param body 
     */
    public releaseVehicleFromService(body?: models.ReleaseVehicleFromServiceDTO, extraHttpRequestParams?: any): Observable<models.ReleaseVehicleResultDTO> {
        return this.releaseVehicleFromServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Rimuove prenotazione da servizio
     * @summary removeBookingFromService
     * @param body 
     */
    public removeBookingFromService(body?: models.RequestRemoveBookingFromService, extraHttpRequestParams?: any): Observable<models.RemoveBookingFromServiceDTO> {
        return this.removeBookingFromServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param code 
     */
    public retrieveVehicle118ByCode(code: string, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.retrieveVehicle118ByCodeWithHttpInfo(code, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di salvare/aggiornare il servizio in input
     * @summary saveService
     * @param body 
     */
    public saveService(body?: models.SaveServiceDTO, extraHttpRequestParams?: any): Observable<models.ServiceDTO> {
        return this.saveServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Recupera le prenotazioni associate ad un veicolo
     * @summary searchBookingsByServiceId
     * @param idService 
     */
    public searchBookingsByServiceId(idService: string, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.searchBookingsByServiceIdWithHttpInfo(idService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di cercare i veicoli per l'assegnazione diretta
     * @summary directAssignmentVehicle
     * @param body 
     */
    public searchDirectAssignmentVehicle(body?: models.VehicleDirectAssignmentFilter, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.searchDirectAssignmentVehicleWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary selectAllAvailableMS
     */
    public selectAllAvailableMS(extraHttpRequestParams?: any): Observable<models.SearchTransportResultDTO> {
        return this.selectAllAvailableMSWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di cercare i veicoli disponibili in turno
     * @summary selectAvailableVehicleTurn
     * @param body 
     */
    public selectAvailableVehicleTurn(body?: models.ParkingVehicleTurnSearchDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.selectAvailableVehicleTurnWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Setta tipo pausa sulla tappa
     * @summary setInterventionStopType
     * @param body 
     */
    public setInterventionStopType(body?: models.RequestInterventionStopTypeService, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.setInterventionStopTypeWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     *  timestamp unificato sulla tappa
     * @summary setInterventionUnified
     * @param body 
     */
    public setInterventionUnified(body?: models.RequestInterventionUnifiedService, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.setInterventionUnifiedWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di cercare i veicoli prossimi a liberarsi
     * @summary shortlyAvailableVehicles
     * @param body 
     */
    public shortlyAvailableVehicles(body?: models.ShortlyAvailableVehiclesSearchDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.shortlyAvailableVehiclesWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di aggiornare la prenotazione in input ed il trasporto relativo
     * @summary updateBookingService
     * @param body 
     */
    public updateBookingService(body?: models.UpdateBookingServiceDTO, extraHttpRequestParams?: any): Observable<models.UpdateBookingServiceDTO> {
        return this.updateBookingServiceWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Permette di salvare i dati della partenza di un mezzo
     * @summary vehicleStart
     * @param body 
     */
    public vehicleStart(body?: models.ServiceResourceInputDTO, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.vehicleStartWithHttpInfo(body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param code 
     */
    public vehicles118Detail(code: string, extraHttpRequestParams?: any): Observable<models.GenericResultDTO> {
        return this.vehicles118DetailWithHttpInfo(code, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * activationVehicle
     * Permette di attivare/riattivare un mezzo su un servizio
     * @param body 
     */
    public activationVehicleServiceWithHttpInfo(body?: models.ActivationVehicleInputDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/activationVehicle';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * addBookingToService
     * Permette di aggiungere una prenotazione ad un servizio pre-esistente
     * @param body 
     */
    public addBookingToServiceWithHttpInfo(body?: models.BookingToServiceInputDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/addBookingToService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * addCrewMembersToService
     * Aggiunge i membri di un equipaggio a un servuzui
     * @param body 
     */
    public addCrewMembersToServiceWithHttpInfo(body?: models.RequestAddCrewMembersToService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/addCrewMembersToService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * addVehicleToService
     * Permette di aggiungere un veicolo ad un servizio
     * @param body 
     */
    public addVehicleToServiceWithHttpInfo(body?: models.AddVehicleToServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/addVehicleToService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * archiveBooking
     * Permette di archiviare la prenotazione creando un servizio chiuso connesso.
     * @param body 
     */
    public archiveBookingWithHttpInfo(body?: models.ArchiveBookingDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/archiveBooking';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * archiveService
     * Permette di archiviare il servizio in input
     * @param body 
     */
    public archiveServiceWithHttpInfo(body?: models.ArchiveServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/archiveService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * checkDifferentDateAddBookingToService
     * Permette di verificare e segnalare la differenza di date tra la prenotazione e il servizio a cui aggiungerlo
     * @param body 
     */
    public checkDifferentDateAddBookingToServiceWithHttpInfo(body?: models.BookingToServiceInputDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/checkDifferentDateAddBookingToService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * checkIsManaged
     * Permette di verificare se un servizio � stato gestito
     * @param idService 
     */
    public checkIsManagedWithHttpInfo(idService: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/checkIsManaged';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'idService' is not null or undefined
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling checkIsManaged.');
        }
        if (idService !== undefined) {
            queryParameters.set('idService', <any>idService);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * checkNonSSNBookingPaid
     * Permette di rilevare se di un servizio sono stati pagati quelli non in regime SSN
     * @param idService 
     */
    public checkNonSSNBookingPaidWithHttpInfo(idService: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/checkNonSSNBookingPaid';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'idService' is not null or undefined
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling checkNonSSNBookingPaid.');
        }
        if (idService !== undefined) {
            queryParameters.set('idService', <any>idService);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * checkUndispatchedService
     * Permette di verificare se un servizio � stato servito
     * @param idService 
     */
    public checkUndispatchedServiceWithHttpInfo(idService: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/checkUndispatchedService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'idService' is not null or undefined
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling checkUndispatchedService.');
        }
        if (idService !== undefined) {
            queryParameters.set('idService', <any>idService);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * createService
     * Permette di creare il servizio per la lista dei trasporti in input
     * @param body 
     */
    public createServiceWithHttpInfo(body?: models.CreateServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/createService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * filterAdvancedTransports
     * 
     * @param body 
     */
    public filterAdvancedTransportsWithHttpInfo(body?: models.FiltroSinotticoAvanzato, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/filterAdvancedTransports';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * filterTransports
     * 
     * @param body 
     */
    public filterTransportsWithHttpInfo(body?: models.FiltroSinottico, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/filterTransports';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * getCiclicalBookingForVirtualService
     * recupera la lista dei booking ciclici collegati per la gestione dei virtual service
     * @param body 
     */
    public getCiclicalBookingForVirtualServiceWithHttpInfo(body?: models.CreateVirtualServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/getCiclicalBookingForVirtualService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * getServiceById
     * Servizio individuato attraverso il suo Id
     * @param idService 
     */
    public getServiceByIdWithHttpInfo(idService: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/getServiceById';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'idService' is not null or undefined
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling getServiceById.');
        }
        if (idService !== undefined) {
            queryParameters.set('idService', <any>idService);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * getServiceCrewMembers
     * REstituisce i membri di equipaggio asseganti ad un servizio
     * @param idService 
     */
    public getServiceCrewMembersWithHttpInfo(idService: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/getServiceCrewMembers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'idService' is not null or undefined
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling getServiceCrewMembers.');
        }
        if (idService !== undefined) {
            queryParameters.set('idService', <any>idService);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * getWorkingResources
     * La lista dei veicoli attivi, esclusi quelli associati al servizio in input se presente
     * @param body 
     */
    public getWorkingResourceListWithHttpInfo(body?: models.WorkingResourceInputDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/getWorkingResources';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * hasTimestampBookingService
     * Verifica se la prenotazione ha rilevamento orario
     * @param body 
     */
    public hasTimestampBookingServiceWithHttpInfo(body?: models.RequestRemoveBookingFromService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/hasTimestampBookingService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * crewMembers
     * Recupera i nominativi dell&#39;equipaggio disponibili rimuovendo quelli con id presenti in input
     */
    public loadCrewMembersWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/info/crewMembers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * loadDeallocateReasons
     * Recupera i motivi di rilascio del mezzo
     * @param travelCompleted 
     */
    public loadDeallocateReasonsWithHttpInfo(travelCompleted?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/info/loadDeallocateReasons';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (travelCompleted !== undefined) {
            queryParameters.set('travelCompleted', <any>travelCompleted);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * loadPauseType
     * Recupera i tipi di pause
     */
    public loadPauseTypeWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/info/loadPauseType';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * modifyInterventionPosition
     * Modifica il nome della postazione
     * @param body 
     */
    public modifyInterventionPositionWithHttpInfo(body?: models.VehiclePositionToChangeRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/modifyInterventionPosition';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * moveInterventionOnArrival
     * Sposta un mezzo nella postazione selezionata
     * @param body 
     */
    public moveInterventionOnArrivalWithHttpInfo(body?: models.MoveInterventionPositionRequestDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/moveInterventionOnArrival';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * moveInterventionOnDestination
     * Avvia un mezzo alla destinazione selezionata
     * @param body 
     */
    public moveInterventionOnDestinationWithHttpInfo(body?: models.MoveInterventionPositionRequestDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/moveInterventionOnDestination';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * moveInterventionPosition
     * Sposta la tappa di prenotazioni accorpate
     * @param body 
     */
    public moveInterventionPositionWithHttpInfo(body?: models.MoveInterventionRequestDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/moveInterventionPosition';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * moveVehicleToOtherService
     * Permette di spostare un veicolo da un ad un altro
     * @param body 
     */
    public moveVehicleToOtherServiceWithHttpInfo(body?: models.MoveVehicleToOtherServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/moveVehicleToOtherService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * releaseVehicleFromService
     * Rimuove un veicolo da un servizio
     * @param body 
     */
    public releaseVehicleFromServiceWithHttpInfo(body?: models.ReleaseVehicleFromServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/releaseVehicleFromService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * removeBookingFromService
     * Rimuove prenotazione da servizio
     * @param body 
     */
    public removeBookingFromServiceWithHttpInfo(body?: models.RequestRemoveBookingFromService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/removeBookingFromService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param code 
     */
    public retrieveVehicle118ByCodeWithHttpInfo(code: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/retrieveVehicle118';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling retrieveVehicle118ByCode.');
        }
        if (code !== undefined) {
            queryParameters.set('code', <any>code);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * saveService
     * Permette di salvare/aggiornare il servizio in input
     * @param body 
     */
    public saveServiceWithHttpInfo(body?: models.SaveServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/saveService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * searchBookingsByServiceId
     * Recupera le prenotazioni associate ad un veicolo
     * @param idService 
     */
    public searchBookingsByServiceIdWithHttpInfo(idService: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/searchBookingsByServiceId';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'idService' is not null or undefined
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling searchBookingsByServiceId.');
        }
        if (idService !== undefined) {
            queryParameters.set('idService', <any>idService);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * directAssignmentVehicle
     * Permette di cercare i veicoli per l&#39;assegnazione diretta
     * @param body 
     */
    public searchDirectAssignmentVehicleWithHttpInfo(body?: models.VehicleDirectAssignmentFilter, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/directAssignmentVehicle';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * selectAllAvailableMS
     * 
     */
    public selectAllAvailableMSWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/selectAllAvailableMS';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * selectAvailableVehicleTurn
     * Permette di cercare i veicoli disponibili in turno
     * @param body 
     */
    public selectAvailableVehicleTurnWithHttpInfo(body?: models.ParkingVehicleTurnSearchDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/selectAvailableVehicleTurn';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * setInterventionStopType
     * Setta tipo pausa sulla tappa
     * @param body 
     */
    public setInterventionStopTypeWithHttpInfo(body?: models.RequestInterventionStopTypeService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/setInterventionStopType';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * setInterventionUnified
     *  timestamp unificato sulla tappa
     * @param body 
     */
    public setInterventionUnifiedWithHttpInfo(body?: models.RequestInterventionUnifiedService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/setInterventionUnified';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * shortlyAvailableVehicles
     * Permette di cercare i veicoli prossimi a liberarsi
     * @param body 
     */
    public shortlyAvailableVehiclesWithHttpInfo(body?: models.ShortlyAvailableVehiclesSearchDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/shortlyAvailableVehicles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * updateBookingService
     * Permette di aggiornare la prenotazione in input ed il trasporto relativo
     * @param body 
     */
    public updateBookingServiceWithHttpInfo(body?: models.UpdateBookingServiceDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/updateBookingService';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * vehicleStart
     * Permette di salvare i dati della partenza di un mezzo
     * @param body 
     */
    public vehicleStartWithHttpInfo(body?: models.ServiceResourceInputDTO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/vehicleStart';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json;charset=UTF-8'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param code 
     */
    public vehicles118DetailWithHttpInfo(code: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/secure/rest/transport/vehicles118Detail';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling vehicles118Detail.');
        }
        if (code !== undefined) {
            queryParameters.set('code', <any>code);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json;charset=UTF-8'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
