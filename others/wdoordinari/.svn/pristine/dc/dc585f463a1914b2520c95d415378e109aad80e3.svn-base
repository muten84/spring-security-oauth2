/**
 * Swagger Maven Plugin Sample
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ActivationVehicleDTO } from '../model/activationVehicleDTO';
import { ActivationVehicleInputDTO } from '../model/activationVehicleInputDTO';
import { AddVehicleToServiceDTO } from '../model/addVehicleToServiceDTO';
import { ArchiveBookingDTO } from '../model/archiveBookingDTO';
import { ArchiveBookingResultDTO } from '../model/archiveBookingResultDTO';
import { ArchiveServiceDTO } from '../model/archiveServiceDTO';
import { BookingToServiceInputDTO } from '../model/bookingToServiceInputDTO';
import { CheckResultDTO } from '../model/checkResultDTO';
import { CiclicalBookingForVirtualServiceDTO } from '../model/ciclicalBookingForVirtualServiceDTO';
import { CreateServiceDTO } from '../model/createServiceDTO';
import { CreateVirtualServiceDTO } from '../model/createVirtualServiceDTO';
import { CrewMemberDTO } from '../model/crewMemberDTO';
import { ErrorMessage } from '../model/errorMessage';
import { FiltroSinottico } from '../model/filtroSinottico';
import { FiltroSinotticoAvanzato } from '../model/filtroSinotticoAvanzato';
import { GenericMessageDTO } from '../model/genericMessageDTO';
import { GenericResultDTO } from '../model/genericResultDTO';
import { GenericResultDTODeallocateReasonDTO } from '../model/genericResultDTODeallocateReasonDTO';
import { GenericResultDTOPauseTypeDTO } from '../model/genericResultDTOPauseTypeDTO';
import { GenericResultDTOServiceDTO } from '../model/genericResultDTOServiceDTO';
import { MoveInterventionPositionRequestDTO } from '../model/moveInterventionPositionRequestDTO';
import { MoveInterventionRequestDTO } from '../model/moveInterventionRequestDTO';
import { MoveVehicleToOtherServiceDTO } from '../model/moveVehicleToOtherServiceDTO';
import { MoveVehicleToOtherServiceResultDTO } from '../model/moveVehicleToOtherServiceResultDTO';
import { ParkingVehicleTurnSearchDTO } from '../model/parkingVehicleTurnSearchDTO';
import { ReleaseVehicleFromServiceDTO } from '../model/releaseVehicleFromServiceDTO';
import { ReleaseVehicleResultDTO } from '../model/releaseVehicleResultDTO';
import { RemoveBookingFromServiceDTO } from '../model/removeBookingFromServiceDTO';
import { RemoveMobileStationDTO } from '../model/removeMobileStationDTO';
import { RequestAddCrewMembersToService } from '../model/requestAddCrewMembersToService';
import { RequestInterventionStopTypeService } from '../model/requestInterventionStopTypeService';
import { RequestInterventionUnifiedService } from '../model/requestInterventionUnifiedService';
import { RequestRemoveBookingFromService } from '../model/requestRemoveBookingFromService';
import { SaveServiceDTO } from '../model/saveServiceDTO';
import { SearchTransportResultDTO } from '../model/searchTransportResultDTO';
import { ServiceCrewDTO } from '../model/serviceCrewDTO';
import { ServiceDTO } from '../model/serviceDTO';
import { ServiceResourceInputDTO } from '../model/serviceResourceInputDTO';
import { ShortlyAvailableVehiclesSearchDTO } from '../model/shortlyAvailableVehiclesSearchDTO';
import { TsServiceResourceDTO } from '../model/tsServiceResourceDTO';
import { UpdateBookingServiceDTO } from '../model/updateBookingServiceDTO';
import { VehicleDirectAssignmentFilter } from '../model/vehicleDirectAssignmentFilter';
import { VehiclePositionToChangeRequest } from '../model/vehiclePositionToChangeRequest';
import { WorkingResourceInputDTO } from '../model/workingResourceInputDTO';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class TransportModuleServiceService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * activationVehicle
     * Permette di attivare/riattivare un mezzo su un servizio
     * @param activationVehicleInputDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public activationVehicleService(activationVehicleInputDTO?: ActivationVehicleInputDTO, observe?: 'body', reportProgress?: boolean): Observable<ActivationVehicleDTO>;
    public activationVehicleService(activationVehicleInputDTO?: ActivationVehicleInputDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ActivationVehicleDTO>>;
    public activationVehicleService(activationVehicleInputDTO?: ActivationVehicleInputDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ActivationVehicleDTO>>;
    public activationVehicleService(activationVehicleInputDTO?: ActivationVehicleInputDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ActivationVehicleDTO>(`${this.basePath}/api/secure/rest/transport/activationVehicle`,
            activationVehicleInputDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addBookingToService
     * Permette di aggiungere una prenotazione ad un servizio pre-esistente
     * @param bookingToServiceInputDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe?: 'body', reportProgress?: boolean): Observable<ServiceDTO>;
    public addBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ServiceDTO>>;
    public addBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ServiceDTO>>;
    public addBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ServiceDTO>(`${this.basePath}/api/secure/rest/transport/addBookingToService`,
            bookingToServiceInputDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addCrewMembersToService
     * Aggiunge i membri di un equipaggio a un servuzui
     * @param requestAddCrewMembersToService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addCrewMembersToService(requestAddCrewMembersToService?: RequestAddCrewMembersToService, observe?: 'body', reportProgress?: boolean): Observable<ServiceCrewDTO>;
    public addCrewMembersToService(requestAddCrewMembersToService?: RequestAddCrewMembersToService, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ServiceCrewDTO>>;
    public addCrewMembersToService(requestAddCrewMembersToService?: RequestAddCrewMembersToService, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ServiceCrewDTO>>;
    public addCrewMembersToService(requestAddCrewMembersToService?: RequestAddCrewMembersToService, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ServiceCrewDTO>(`${this.basePath}/api/secure/rest/transport/addCrewMembersToService`,
            requestAddCrewMembersToService,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addVehicleToService
     * Permette di aggiungere un veicolo ad un servizio
     * @param addVehicleToServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addVehicleToService(addVehicleToServiceDTO?: AddVehicleToServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public addVehicleToService(addVehicleToServiceDTO?: AddVehicleToServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public addVehicleToService(addVehicleToServiceDTO?: AddVehicleToServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public addVehicleToService(addVehicleToServiceDTO?: AddVehicleToServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/addVehicleToService`,
            addVehicleToServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * archiveBooking
     * Permette di archiviare la prenotazione creando un servizio chiuso connesso.
     * @param archiveBookingDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public archiveBooking(archiveBookingDTO?: ArchiveBookingDTO, observe?: 'body', reportProgress?: boolean): Observable<ArchiveBookingResultDTO>;
    public archiveBooking(archiveBookingDTO?: ArchiveBookingDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArchiveBookingResultDTO>>;
    public archiveBooking(archiveBookingDTO?: ArchiveBookingDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArchiveBookingResultDTO>>;
    public archiveBooking(archiveBookingDTO?: ArchiveBookingDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ArchiveBookingResultDTO>(`${this.basePath}/api/secure/rest/transport/archiveBooking`,
            archiveBookingDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * archiveService
     * Permette di archiviare il servizio in input
     * @param archiveServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public archiveService(archiveServiceDTO?: ArchiveServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public archiveService(archiveServiceDTO?: ArchiveServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public archiveService(archiveServiceDTO?: ArchiveServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public archiveService(archiveServiceDTO?: ArchiveServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/archiveService`,
            archiveServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * checkDifferentDateAddBookingToService
     * Permette di verificare e segnalare la differenza di date tra la prenotazione e il servizio a cui aggiungerlo
     * @param bookingToServiceInputDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkDifferentDateAddBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe?: 'body', reportProgress?: boolean): Observable<CheckResultDTO>;
    public checkDifferentDateAddBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CheckResultDTO>>;
    public checkDifferentDateAddBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckResultDTO>>;
    public checkDifferentDateAddBookingToService(bookingToServiceInputDTO?: BookingToServiceInputDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CheckResultDTO>(`${this.basePath}/api/secure/rest/transport/checkDifferentDateAddBookingToService`,
            bookingToServiceInputDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * checkIsManaged
     * Permette di verificare se un servizio � stato gestito
     * @param idService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkIsManaged(idService: string, observe?: 'body', reportProgress?: boolean): Observable<CheckResultDTO>;
    public checkIsManaged(idService: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CheckResultDTO>>;
    public checkIsManaged(idService: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckResultDTO>>;
    public checkIsManaged(idService: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling checkIsManaged.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CheckResultDTO>(`${this.basePath}/api/secure/rest/transport/checkIsManaged`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * checkNonSSNBookingPaid
     * Permette di rilevare se di un servizio sono stati pagati quelli non in regime SSN
     * @param idService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkNonSSNBookingPaid(idService: string, observe?: 'body', reportProgress?: boolean): Observable<CheckResultDTO>;
    public checkNonSSNBookingPaid(idService: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CheckResultDTO>>;
    public checkNonSSNBookingPaid(idService: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckResultDTO>>;
    public checkNonSSNBookingPaid(idService: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling checkNonSSNBookingPaid.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CheckResultDTO>(`${this.basePath}/api/secure/rest/transport/checkNonSSNBookingPaid`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * checkUndispatchedService
     * Permette di verificare se un servizio � stato servito
     * @param idService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkUndispatchedService(idService: string, observe?: 'body', reportProgress?: boolean): Observable<CheckResultDTO>;
    public checkUndispatchedService(idService: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CheckResultDTO>>;
    public checkUndispatchedService(idService: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckResultDTO>>;
    public checkUndispatchedService(idService: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling checkUndispatchedService.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CheckResultDTO>(`${this.basePath}/api/secure/rest/transport/checkUndispatchedService`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * createService
     * Permette di creare il servizio per la lista dei trasporti in input
     * @param createServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createService(createServiceDTO?: CreateServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public createService(createServiceDTO?: CreateServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public createService(createServiceDTO?: CreateServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public createService(createServiceDTO?: CreateServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/createService`,
            createServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * filterAdvancedTransports
     * 
     * @param filtroSinotticoAvanzato 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public filterAdvancedTransports(filtroSinotticoAvanzato?: FiltroSinotticoAvanzato, observe?: 'body', reportProgress?: boolean): Observable<SearchTransportResultDTO>;
    public filterAdvancedTransports(filtroSinotticoAvanzato?: FiltroSinotticoAvanzato, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchTransportResultDTO>>;
    public filterAdvancedTransports(filtroSinotticoAvanzato?: FiltroSinotticoAvanzato, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchTransportResultDTO>>;
    public filterAdvancedTransports(filtroSinotticoAvanzato?: FiltroSinotticoAvanzato, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<SearchTransportResultDTO>(`${this.basePath}/api/secure/rest/transport/filterAdvancedTransports`,
            filtroSinotticoAvanzato,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * filterTransports
     * 
     * @param filtroSinottico 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public filterTransports(filtroSinottico?: FiltroSinottico, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public filterTransports(filtroSinottico?: FiltroSinottico, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public filterTransports(filtroSinottico?: FiltroSinottico, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public filterTransports(filtroSinottico?: FiltroSinottico, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/filterTransports`,
            filtroSinottico,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getAllocatedServiceResources
     * Recupera le risorse allocate ad un servizio
     * @param idService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllocatedServiceResources(idService: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TsServiceResourceDTO>>;
    public getAllocatedServiceResources(idService: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsServiceResourceDTO>>>;
    public getAllocatedServiceResources(idService: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsServiceResourceDTO>>>;
    public getAllocatedServiceResources(idService: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling getAllocatedServiceResources.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsServiceResourceDTO>>(`${this.basePath}/api/secure/rest/transport/getAllocatedServiceResources`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getCiclicalBookingForVirtualService
     * recupera la lista dei booking ciclici collegati per la gestione dei virtual service
     * @param createVirtualServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCiclicalBookingForVirtualService(createVirtualServiceDTO?: CreateVirtualServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<Array<CiclicalBookingForVirtualServiceDTO>>;
    public getCiclicalBookingForVirtualService(createVirtualServiceDTO?: CreateVirtualServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CiclicalBookingForVirtualServiceDTO>>>;
    public getCiclicalBookingForVirtualService(createVirtualServiceDTO?: CreateVirtualServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CiclicalBookingForVirtualServiceDTO>>>;
    public getCiclicalBookingForVirtualService(createVirtualServiceDTO?: CreateVirtualServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<CiclicalBookingForVirtualServiceDTO>>(`${this.basePath}/api/secure/rest/transport/getCiclicalBookingForVirtualService`,
            createVirtualServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceById
     * Servizio individuato attraverso il suo Id
     * @param idService 
     * @param source 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceById(idService: string, source?: string, observe?: 'body', reportProgress?: boolean): Observable<ServiceDTO>;
    public getServiceById(idService: string, source?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ServiceDTO>>;
    public getServiceById(idService: string, source?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ServiceDTO>>;
    public getServiceById(idService: string, source?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling getServiceById.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (source !== undefined && source !== null) {
            queryParameters = queryParameters.set('source', <any>source);
        }
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ServiceDTO>(`${this.basePath}/api/secure/rest/transport/getServiceById`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceCrewMembers
     * REstituisce i membri di equipaggio asseganti ad un servizio
     * @param idService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceCrewMembers(idService: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CrewMemberDTO>>;
    public getServiceCrewMembers(idService: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CrewMemberDTO>>>;
    public getServiceCrewMembers(idService: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CrewMemberDTO>>>;
    public getServiceCrewMembers(idService: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling getServiceCrewMembers.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CrewMemberDTO>>(`${this.basePath}/api/secure/rest/transport/getServiceCrewMembers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getWorkingResources
     * La lista dei veicoli attivi, esclusi quelli associati al servizio in input se presente
     * @param workingResourceInputDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkingResourceList(workingResourceInputDTO?: WorkingResourceInputDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public getWorkingResourceList(workingResourceInputDTO?: WorkingResourceInputDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public getWorkingResourceList(workingResourceInputDTO?: WorkingResourceInputDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public getWorkingResourceList(workingResourceInputDTO?: WorkingResourceInputDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/getWorkingResources`,
            workingResourceInputDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * hasTimestampBookingService
     * Verifica se la prenotazione ha rilevamento orario
     * @param requestRemoveBookingFromService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public hasTimestampBookingService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe?: 'body', reportProgress?: boolean): Observable<CheckResultDTO>;
    public hasTimestampBookingService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CheckResultDTO>>;
    public hasTimestampBookingService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckResultDTO>>;
    public hasTimestampBookingService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CheckResultDTO>(`${this.basePath}/api/secure/rest/transport/hasTimestampBookingService`,
            requestRemoveBookingFromService,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * crewMembers
     * Recupera i nominativi dell&#39;equipaggio disponibili rimuovendo quelli con id presenti in input
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loadCrewMembers(observe?: 'body', reportProgress?: boolean): Observable<Array<CrewMemberDTO>>;
    public loadCrewMembers(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CrewMemberDTO>>>;
    public loadCrewMembers(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CrewMemberDTO>>>;
    public loadCrewMembers(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<Array<CrewMemberDTO>>(`${this.basePath}/api/secure/rest/transport/info/crewMembers`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * loadDeallocateReasons
     * Recupera i motivi di rilascio del mezzo
     * @param travelCompleted 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loadDeallocateReasons(travelCompleted?: boolean, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTODeallocateReasonDTO>;
    public loadDeallocateReasons(travelCompleted?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTODeallocateReasonDTO>>;
    public loadDeallocateReasons(travelCompleted?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTODeallocateReasonDTO>>;
    public loadDeallocateReasons(travelCompleted?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (travelCompleted !== undefined && travelCompleted !== null) {
            queryParameters = queryParameters.set('travelCompleted', <any>travelCompleted);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<GenericResultDTODeallocateReasonDTO>(`${this.basePath}/api/secure/rest/transport/info/loadDeallocateReasons`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * loadPauseType
     * Recupera i tipi di pause
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loadPauseType(observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTOPauseTypeDTO>;
    public loadPauseType(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTOPauseTypeDTO>>;
    public loadPauseType(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTOPauseTypeDTO>>;
    public loadPauseType(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<GenericResultDTOPauseTypeDTO>(`${this.basePath}/api/secure/rest/transport/info/loadPauseType`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * modifyInterventionPosition
     * Modifica il nome della postazione
     * @param vehiclePositionToChangeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifyInterventionPosition(vehiclePositionToChangeRequest?: VehiclePositionToChangeRequest, observe?: 'body', reportProgress?: boolean): Observable<VehiclePositionToChangeRequest>;
    public modifyInterventionPosition(vehiclePositionToChangeRequest?: VehiclePositionToChangeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VehiclePositionToChangeRequest>>;
    public modifyInterventionPosition(vehiclePositionToChangeRequest?: VehiclePositionToChangeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VehiclePositionToChangeRequest>>;
    public modifyInterventionPosition(vehiclePositionToChangeRequest?: VehiclePositionToChangeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<VehiclePositionToChangeRequest>(`${this.basePath}/api/secure/rest/transport/modifyInterventionPosition`,
            vehiclePositionToChangeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * moveInterventionOnArrival
     * Sposta un mezzo nella postazione selezionata
     * @param moveInterventionPositionRequestDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveInterventionOnArrival(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public moveInterventionOnArrival(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public moveInterventionOnArrival(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public moveInterventionOnArrival(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/moveInterventionOnArrival`,
            moveInterventionPositionRequestDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * moveInterventionOnDestination
     * Avvia un mezzo alla destinazione selezionata
     * @param moveInterventionPositionRequestDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveInterventionOnDestination(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public moveInterventionOnDestination(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public moveInterventionOnDestination(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public moveInterventionOnDestination(moveInterventionPositionRequestDTO?: MoveInterventionPositionRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/moveInterventionOnDestination`,
            moveInterventionPositionRequestDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * moveInterventionPosition
     * Sposta la tappa di prenotazioni accorpate
     * @param moveInterventionRequestDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveInterventionPosition(moveInterventionRequestDTO?: MoveInterventionRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTOServiceDTO>;
    public moveInterventionPosition(moveInterventionRequestDTO?: MoveInterventionRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTOServiceDTO>>;
    public moveInterventionPosition(moveInterventionRequestDTO?: MoveInterventionRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTOServiceDTO>>;
    public moveInterventionPosition(moveInterventionRequestDTO?: MoveInterventionRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTOServiceDTO>(`${this.basePath}/api/secure/rest/transport/moveInterventionPosition`,
            moveInterventionRequestDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * moveVehicleToOtherService
     * Permette di spostare un veicolo da un ad un altro
     * @param moveVehicleToOtherServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveVehicleToOtherService(moveVehicleToOtherServiceDTO?: MoveVehicleToOtherServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<MoveVehicleToOtherServiceResultDTO>;
    public moveVehicleToOtherService(moveVehicleToOtherServiceDTO?: MoveVehicleToOtherServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MoveVehicleToOtherServiceResultDTO>>;
    public moveVehicleToOtherService(moveVehicleToOtherServiceDTO?: MoveVehicleToOtherServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MoveVehicleToOtherServiceResultDTO>>;
    public moveVehicleToOtherService(moveVehicleToOtherServiceDTO?: MoveVehicleToOtherServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<MoveVehicleToOtherServiceResultDTO>(`${this.basePath}/api/secure/rest/transport/moveVehicleToOtherService`,
            moveVehicleToOtherServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * releaseVehicleFromService
     * Rimuove un veicolo da un servizio
     * @param releaseVehicleFromServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public releaseVehicleFromService(releaseVehicleFromServiceDTO?: ReleaseVehicleFromServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<ReleaseVehicleResultDTO>;
    public releaseVehicleFromService(releaseVehicleFromServiceDTO?: ReleaseVehicleFromServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ReleaseVehicleResultDTO>>;
    public releaseVehicleFromService(releaseVehicleFromServiceDTO?: ReleaseVehicleFromServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ReleaseVehicleResultDTO>>;
    public releaseVehicleFromService(releaseVehicleFromServiceDTO?: ReleaseVehicleFromServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ReleaseVehicleResultDTO>(`${this.basePath}/api/secure/rest/transport/releaseVehicleFromService`,
            releaseVehicleFromServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeBookingFromService
     * Rimuove prenotazione da servizio
     * @param requestRemoveBookingFromService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeBookingFromService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe?: 'body', reportProgress?: boolean): Observable<RemoveBookingFromServiceDTO>;
    public removeBookingFromService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RemoveBookingFromServiceDTO>>;
    public removeBookingFromService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RemoveBookingFromServiceDTO>>;
    public removeBookingFromService(requestRemoveBookingFromService?: RequestRemoveBookingFromService, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<RemoveBookingFromServiceDTO>(`${this.basePath}/api/secure/rest/transport/removeBookingFromService`,
            requestRemoveBookingFromService,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeMobileStation
     * Rimuove mobile station da elenco
     * @param idSession 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeMobileStation(idSession: string, observe?: 'body', reportProgress?: boolean): Observable<RemoveMobileStationDTO>;
    public removeMobileStation(idSession: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RemoveMobileStationDTO>>;
    public removeMobileStation(idSession: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RemoveMobileStationDTO>>;
    public removeMobileStation(idSession: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idSession === null || idSession === undefined) {
            throw new Error('Required parameter idSession was null or undefined when calling removeMobileStation.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idSession !== undefined && idSession !== null) {
            queryParameters = queryParameters.set('idSession', <any>idSession);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RemoveMobileStationDTO>(`${this.basePath}/api/secure/rest/transport/removeMobileStation`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param code 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public retrieveVehicle118ByCode(code: string, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public retrieveVehicle118ByCode(code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public retrieveVehicle118ByCode(code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public retrieveVehicle118ByCode(code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling retrieveVehicle118ByCode.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (code !== undefined && code !== null) {
            queryParameters = queryParameters.set('code', <any>code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/retrieveVehicle118`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * saveService
     * Permette di salvare/aggiornare il servizio in input
     * @param saveServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveService(saveServiceDTO?: SaveServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<ServiceDTO>;
    public saveService(saveServiceDTO?: SaveServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ServiceDTO>>;
    public saveService(saveServiceDTO?: SaveServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ServiceDTO>>;
    public saveService(saveServiceDTO?: SaveServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ServiceDTO>(`${this.basePath}/api/secure/rest/transport/saveService`,
            saveServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * searchBookingsByServiceId
     * Recupera le prenotazioni associate ad un veicolo
     * @param idService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchBookingsByServiceId(idService: string, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public searchBookingsByServiceId(idService: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public searchBookingsByServiceId(idService: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public searchBookingsByServiceId(idService: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (idService === null || idService === undefined) {
            throw new Error('Required parameter idService was null or undefined when calling searchBookingsByServiceId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idService !== undefined && idService !== null) {
            queryParameters = queryParameters.set('idService', <any>idService);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/searchBookingsByServiceId`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * directAssignmentVehicle
     * Permette di cercare i veicoli per l&#39;assegnazione diretta
     * @param vehicleDirectAssignmentFilter 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchDirectAssignmentVehicle(vehicleDirectAssignmentFilter?: VehicleDirectAssignmentFilter, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public searchDirectAssignmentVehicle(vehicleDirectAssignmentFilter?: VehicleDirectAssignmentFilter, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public searchDirectAssignmentVehicle(vehicleDirectAssignmentFilter?: VehicleDirectAssignmentFilter, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public searchDirectAssignmentVehicle(vehicleDirectAssignmentFilter?: VehicleDirectAssignmentFilter, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/directAssignmentVehicle`,
            vehicleDirectAssignmentFilter,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * selectAllAvailableMS
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public selectAllAvailableMS(observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public selectAllAvailableMS(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public selectAllAvailableMS(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public selectAllAvailableMS(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/selectAllAvailableMS`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * selectAvailableVehicleTurn
     * Permette di cercare i veicoli disponibili in turno
     * @param parkingVehicleTurnSearchDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public selectAvailableVehicleTurn(parkingVehicleTurnSearchDTO?: ParkingVehicleTurnSearchDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public selectAvailableVehicleTurn(parkingVehicleTurnSearchDTO?: ParkingVehicleTurnSearchDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public selectAvailableVehicleTurn(parkingVehicleTurnSearchDTO?: ParkingVehicleTurnSearchDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public selectAvailableVehicleTurn(parkingVehicleTurnSearchDTO?: ParkingVehicleTurnSearchDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/selectAvailableVehicleTurn`,
            parkingVehicleTurnSearchDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * setInterventionStopType
     * Setta tipo pausa sulla tappa
     * @param requestInterventionStopTypeService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setInterventionStopType(requestInterventionStopTypeService?: RequestInterventionStopTypeService, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public setInterventionStopType(requestInterventionStopTypeService?: RequestInterventionStopTypeService, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public setInterventionStopType(requestInterventionStopTypeService?: RequestInterventionStopTypeService, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public setInterventionStopType(requestInterventionStopTypeService?: RequestInterventionStopTypeService, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/setInterventionStopType`,
            requestInterventionStopTypeService,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * setInterventionUnified
     *  timestamp unificato sulla tappa
     * @param requestInterventionUnifiedService 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setInterventionUnified(requestInterventionUnifiedService?: RequestInterventionUnifiedService, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public setInterventionUnified(requestInterventionUnifiedService?: RequestInterventionUnifiedService, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public setInterventionUnified(requestInterventionUnifiedService?: RequestInterventionUnifiedService, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public setInterventionUnified(requestInterventionUnifiedService?: RequestInterventionUnifiedService, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/setInterventionUnified`,
            requestInterventionUnifiedService,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * shortlyAvailableVehicles
     * Permette di cercare i veicoli prossimi a liberarsi
     * @param shortlyAvailableVehiclesSearchDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public shortlyAvailableVehicles(shortlyAvailableVehiclesSearchDTO?: ShortlyAvailableVehiclesSearchDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public shortlyAvailableVehicles(shortlyAvailableVehiclesSearchDTO?: ShortlyAvailableVehiclesSearchDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public shortlyAvailableVehicles(shortlyAvailableVehiclesSearchDTO?: ShortlyAvailableVehiclesSearchDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public shortlyAvailableVehicles(shortlyAvailableVehiclesSearchDTO?: ShortlyAvailableVehiclesSearchDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/shortlyAvailableVehicles`,
            shortlyAvailableVehiclesSearchDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateBookingService
     * Permette di aggiornare la prenotazione in input ed il trasporto relativo
     * @param updateBookingServiceDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateBookingService(updateBookingServiceDTO?: UpdateBookingServiceDTO, observe?: 'body', reportProgress?: boolean): Observable<UpdateBookingServiceDTO>;
    public updateBookingService(updateBookingServiceDTO?: UpdateBookingServiceDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateBookingServiceDTO>>;
    public updateBookingService(updateBookingServiceDTO?: UpdateBookingServiceDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateBookingServiceDTO>>;
    public updateBookingService(updateBookingServiceDTO?: UpdateBookingServiceDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<UpdateBookingServiceDTO>(`${this.basePath}/api/secure/rest/transport/updateBookingService`,
            updateBookingServiceDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * vehicleStart
     * Permette di salvare i dati della partenza di un mezzo
     * @param serviceResourceInputDTO 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public vehicleStart(serviceResourceInputDTO?: ServiceResourceInputDTO, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public vehicleStart(serviceResourceInputDTO?: ServiceResourceInputDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public vehicleStart(serviceResourceInputDTO?: ServiceResourceInputDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public vehicleStart(serviceResourceInputDTO?: ServiceResourceInputDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/vehicleStart`,
            serviceResourceInputDTO,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param code 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public vehicles118Detail(code: string, observe?: 'body', reportProgress?: boolean): Observable<GenericResultDTO>;
    public vehicles118Detail(code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericResultDTO>>;
    public vehicles118Detail(code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericResultDTO>>;
    public vehicles118Detail(code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling vehicles118Detail.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (code !== undefined && code !== null) {
            queryParameters = queryParameters.set('code', <any>code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<GenericResultDTO>(`${this.basePath}/api/secure/rest/transport/vehicles118Detail`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
